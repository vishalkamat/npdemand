#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Nov 23 18:02:11 2022

@author: vishalkamat
"""

import numpy as np

#------------------------------------------------------------------------------
# Store function in same directory as main file and import the function
#------------------------------------------------------------------------------

from npdemand import *

#------------------------------------------------------------------------------
# Simulate data
#------------------------------------------------------------------------------

np.random.seed(123) 

#Suppose we have 5 alternatives

J_n           = 5 

#Suppoe we observe original prices p_0 = [0,1000,2000,3000,4000] and a discount of 250 and 500, 
# i.e. p_1 = [0,750,1750,2750,3750] and p_2 [0,500,1500,2500,3500]. 

p_0, p_1, p_2 = np.zeros(J_n), np.zeros(J_n), np.zeros(J_n)  #Initialize numpy arrays for price decrease and observed price
for j in range(J_n):
    p_0[j] = 1000*j
    p_1[j] = max(1000*j - 500,0)
    p_2[j] = max(1000*j - 250,0)
    
#Suppose that a sample of 5000 observed choices under these prices are generated by the following model with independent normal errors

n  = 5000    #sample size
Z  = np.random.randint(3, size=n)  #deterines where individual faces p_a, p_b or p_1
U0 = np.zeros(n)                   #utility under alternative 0 is normalized to 0
U1 = 1000 - 1.5 * ((Z == 0) * p_0[1] + (Z == 1) * p_1[1] + (Z == 2) * p_2[1]) + np.random.normal(0, 1000, size=n)
U2 = 2000 - 1.5 * ((Z == 0) * p_0[2] + (Z == 1) * p_1[2] + (Z == 2) * p_2[2]) + np.random.normal(0, 1000, size=n)
U3 = 3000 - 1.5 * ((Z == 0) * p_0[3] + (Z == 1) * p_1[3] + (Z == 2) * p_2[3]) + np.random.normal(0, 1000, size=n)
U4 = 4000 - 1.5 * ((Z == 0) * p_0[4] + (Z == 1) * p_1[4] + (Z == 2) * p_2[4]) + np.random.normal(0, 1000, size=n)
D  = np.zeros(n)  #initial numpy array to store observed choice
for i in range(n):
    D[i] = np.argsort([U0[i],U1[i],U2[i],U3[i],U4[i]])[4]   #observed choice is the one that maximizes utility

#------------------------------------------------------------------------------
# Prepare data of the form (D_i,P_i) to that we can input in npdemand
# Note: P_i here is determined by (Z == 0) * p_0 + (Z == 1) * p_1 + (Z == 2) * p_2
#------------------------------------------------------------------------------

#Support of observed prices

P_obs = [p_0, p_1, p_2]

#Compute choice probabilities under observed prices and store them in a list in same order as observed prices

share = []
for z in [0,1,2]:
    temp = np.zeros(J_n)
    for j in range(J_n):
        temp[j] = np.sum((D == j) * (Z == z)) / np.sum((Z == z))
    share.append(temp)

#Compute the above for each bootstrap sample store in a dictionary

share_b = {}
for b in range(1,101):
    idx        = np.random.choice(n, n)
    D_b, Z_b   = D[idx], Z[idx]
    share_b[b] = []
    for z in [0,1,2]:
        temp = np.zeros(J_n)
        for j in range(J_n):
            temp[j] = np.sum((D_b == j) * (Z == z)) / np.sum((Z_b == z))
        share_b[b].append(temp)

#------------------------------------------------------------------------------        
# Evaluate average willingness to pay for price decrease from p_0 to p_1
#------------------------------------------------------------------------------

#Set g_ab =1 and g_a and g_b to an array of zeros

p_a, p_b       = p_0, p_1
g_ab, g_a, g_b = 1, np.zeros(J_n), np.zeros(J_n)

#1. Compute without computing confidence intervals

output = npdemand(p_a,p_b,P_obs,share,g_a,g_b,g_ab)

#2. Compute with confidence intervals with default options

output = npdemand(p_a,p_b,P_obs,share,g_a,g_b,g_ab,conf=1,share_b=share_b,n=n)

#3. Compute with confidence intervals with default options + specificaiton of nonparametric seprable demand

output = npdemand(p_a,p_b,P_obs,share,g_a,g_b,g_ab,conf=1,share_b=share_b,n=n,spec="NPS")

#4. Compute with confidence intervals with default options + specificaiton of parametric seprable demand

output = npdemand(p_a,p_b,P_obs,share,g_a,g_b,g_ab,conf=1,share_b=share_b,n=n,spec="PS")

#------------------------------------------------------------------------------        
# Evaluate effect on demand of choosing alternative 0 of counterfactual general price change
# from p_a to an intermediate discount of 250 that doesn't applies to alternative 2, 
# which has a price rise of 500, i.e. [0,750,2000,2750,3750] 
#------------------------------------------------------------------------------

p_counter = np.zeros(J_n)  #Initialize numpy arrays for price decrease and observed price
for j in range(J_n):
    if j == 2:
        p_counter[j] = max(1000*j + 500,0)
    else:
        p_counter[j] = max(1000*j - 250,0)

#Set g_ab = 0 and g_a and g_b to an array of zeros but with g_a[0] = 1 and g_b[0] = -1 

p_a, p_b       = p_0, p_counter       
g_ab, g_a, g_b = 0, np.zeros(J_n), np.zeros(J_n)
g_a[0], g_b[0] = 1, -1

#Compute with confidence intervals with default options and confidence intervals

output = npdemand(p_a,p_b,P_obs,share,g_a,g_b,g_ab,conf=1,share_b=share_b,n=n)
    